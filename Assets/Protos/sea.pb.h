// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sea.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sea_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sea_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sea_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sea_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sea_2eproto;
namespace sea {
class ConfigFeedback;
struct ConfigFeedbackDefaultTypeInternal;
extern ConfigFeedbackDefaultTypeInternal _ConfigFeedback_default_instance_;
class ControlCommand;
struct ControlCommandDefaultTypeInternal;
extern ControlCommandDefaultTypeInternal _ControlCommand_default_instance_;
class ControlFeedback;
struct ControlFeedbackDefaultTypeInternal;
extern ControlFeedbackDefaultTypeInternal _ControlFeedback_default_instance_;
class EnableCommand;
struct EnableCommandDefaultTypeInternal;
extern EnableCommandDefaultTypeInternal _EnableCommand_default_instance_;
class SetDampingCommand;
struct SetDampingCommandDefaultTypeInternal;
extern SetDampingCommandDefaultTypeInternal _SetDampingCommand_default_instance_;
class SetPositionCommand;
struct SetPositionCommandDefaultTypeInternal;
extern SetPositionCommandDefaultTypeInternal _SetPositionCommand_default_instance_;
class SetStiffnessCommand;
struct SetStiffnessCommandDefaultTypeInternal;
extern SetStiffnessCommandDefaultTypeInternal _SetStiffnessCommand_default_instance_;
class SetVelocityCommand;
struct SetVelocityCommandDefaultTypeInternal;
extern SetVelocityCommandDefaultTypeInternal _SetVelocityCommand_default_instance_;
class SetWorkModeCommand;
struct SetWorkModeCommandDefaultTypeInternal;
extern SetWorkModeCommandDefaultTypeInternal _SetWorkModeCommand_default_instance_;
class StatusFeedback;
struct StatusFeedbackDefaultTypeInternal;
extern StatusFeedbackDefaultTypeInternal _StatusFeedback_default_instance_;
}  // namespace sea
PROTOBUF_NAMESPACE_OPEN
template<> ::sea::ConfigFeedback* Arena::CreateMaybeMessage<::sea::ConfigFeedback>(Arena*);
template<> ::sea::ControlCommand* Arena::CreateMaybeMessage<::sea::ControlCommand>(Arena*);
template<> ::sea::ControlFeedback* Arena::CreateMaybeMessage<::sea::ControlFeedback>(Arena*);
template<> ::sea::EnableCommand* Arena::CreateMaybeMessage<::sea::EnableCommand>(Arena*);
template<> ::sea::SetDampingCommand* Arena::CreateMaybeMessage<::sea::SetDampingCommand>(Arena*);
template<> ::sea::SetPositionCommand* Arena::CreateMaybeMessage<::sea::SetPositionCommand>(Arena*);
template<> ::sea::SetStiffnessCommand* Arena::CreateMaybeMessage<::sea::SetStiffnessCommand>(Arena*);
template<> ::sea::SetVelocityCommand* Arena::CreateMaybeMessage<::sea::SetVelocityCommand>(Arena*);
template<> ::sea::SetWorkModeCommand* Arena::CreateMaybeMessage<::sea::SetWorkModeCommand>(Arena*);
template<> ::sea::StatusFeedback* Arena::CreateMaybeMessage<::sea::StatusFeedback>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sea {

enum RunState : int {
  DISABLED = 0,
  STOPPED = 1,
  RUNNING = 2,
  UNKNOWN = 3,
  ERROR = 4,
  RunState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RunState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RunState_IsValid(int value);
constexpr RunState RunState_MIN = DISABLED;
constexpr RunState RunState_MAX = ERROR;
constexpr int RunState_ARRAYSIZE = RunState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RunState_descriptor();
template<typename T>
inline const std::string& RunState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RunState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RunState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RunState_descriptor(), enum_t_value);
}
inline bool RunState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RunState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RunState>(
    RunState_descriptor(), name, value);
}
enum WorkMode : int {
  IMPEDANCE = 0,
  ZERO_FORCE = 1,
  POSITION = 2,
  VELOCITY = 3,
  WorkMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkMode_IsValid(int value);
constexpr WorkMode WorkMode_MIN = IMPEDANCE;
constexpr WorkMode WorkMode_MAX = VELOCITY;
constexpr int WorkMode_ARRAYSIZE = WorkMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkMode_descriptor();
template<typename T>
inline const std::string& WorkMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkMode_descriptor(), enum_t_value);
}
inline bool WorkMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkMode>(
    WorkMode_descriptor(), name, value);
}
// ===================================================================

class StatusFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.StatusFeedback) */ {
 public:
  inline StatusFeedback() : StatusFeedback(nullptr) {}
  ~StatusFeedback() override;
  explicit constexpr StatusFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusFeedback(const StatusFeedback& from);
  StatusFeedback(StatusFeedback&& from) noexcept
    : StatusFeedback() {
    *this = ::std::move(from);
  }

  inline StatusFeedback& operator=(const StatusFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusFeedback& operator=(StatusFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusFeedback* internal_default_instance() {
    return reinterpret_cast<const StatusFeedback*>(
               &_StatusFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StatusFeedback& a, StatusFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusFeedback* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusFeedback* New() const final {
    return new StatusFeedback();
  }

  StatusFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatusFeedback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.StatusFeedback";
  }
  protected:
  explicit StatusFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunStateFieldNumber = 1,
    kWorkModeFieldNumber = 2,
    kCurrentPositionFieldNumber = 3,
    kCurrentVelocityFieldNumber = 4,
    kEncoder1FeedbackFieldNumber = 5,
    kEncoder2FeedbackFieldNumber = 6,
    kExternalForceFieldNumber = 7,
    kStiffnessFieldNumber = 8,
    kDampingFieldNumber = 9,
  };
  // .sea.RunState run_state = 1;
  void clear_run_state();
  ::sea::RunState run_state() const;
  void set_run_state(::sea::RunState value);
  private:
  ::sea::RunState _internal_run_state() const;
  void _internal_set_run_state(::sea::RunState value);
  public:

  // .sea.WorkMode work_mode = 2;
  void clear_work_mode();
  ::sea::WorkMode work_mode() const;
  void set_work_mode(::sea::WorkMode value);
  private:
  ::sea::WorkMode _internal_work_mode() const;
  void _internal_set_work_mode(::sea::WorkMode value);
  public:

  // double current_position = 3;
  void clear_current_position();
  double current_position() const;
  void set_current_position(double value);
  private:
  double _internal_current_position() const;
  void _internal_set_current_position(double value);
  public:

  // double current_velocity = 4;
  void clear_current_velocity();
  double current_velocity() const;
  void set_current_velocity(double value);
  private:
  double _internal_current_velocity() const;
  void _internal_set_current_velocity(double value);
  public:

  // int32 encoder1_feedback = 5;
  void clear_encoder1_feedback();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder1_feedback() const;
  void set_encoder1_feedback(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder1_feedback() const;
  void _internal_set_encoder1_feedback(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 encoder2_feedback = 6;
  void clear_encoder2_feedback();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder2_feedback() const;
  void set_encoder2_feedback(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder2_feedback() const;
  void _internal_set_encoder2_feedback(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double external_force = 7;
  void clear_external_force();
  double external_force() const;
  void set_external_force(double value);
  private:
  double _internal_external_force() const;
  void _internal_set_external_force(double value);
  public:

  // double stiffness = 8;
  void clear_stiffness();
  double stiffness() const;
  void set_stiffness(double value);
  private:
  double _internal_stiffness() const;
  void _internal_set_stiffness(double value);
  public:

  // double damping = 9;
  void clear_damping();
  double damping() const;
  void set_damping(double value);
  private:
  double _internal_damping() const;
  void _internal_set_damping(double value);
  public:

  // @@protoc_insertion_point(class_scope:sea.StatusFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int run_state_;
  int work_mode_;
  double current_position_;
  double current_velocity_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder1_feedback_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder2_feedback_;
  double external_force_;
  double stiffness_;
  double damping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class ConfigFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.ConfigFeedback) */ {
 public:
  inline ConfigFeedback() : ConfigFeedback(nullptr) {}
  ~ConfigFeedback() override;
  explicit constexpr ConfigFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigFeedback(const ConfigFeedback& from);
  ConfigFeedback(ConfigFeedback&& from) noexcept
    : ConfigFeedback() {
    *this = ::std::move(from);
  }

  inline ConfigFeedback& operator=(const ConfigFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigFeedback& operator=(ConfigFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigFeedback* internal_default_instance() {
    return reinterpret_cast<const ConfigFeedback*>(
               &_ConfigFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConfigFeedback& a, ConfigFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigFeedback* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigFeedback* New() const final {
    return new ConfigFeedback();
  }

  ConfigFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigFeedback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.ConfigFeedback";
  }
  protected:
  explicit ConfigFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoder1ResolutionFieldNumber = 1,
    kEncoder2ResolutionFieldNumber = 2,
    kSpringStiffnessFieldNumber = 3,
  };
  // int32 encoder1_resolution = 1;
  void clear_encoder1_resolution();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder1_resolution() const;
  void set_encoder1_resolution(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder1_resolution() const;
  void _internal_set_encoder1_resolution(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 encoder2_resolution = 2;
  void clear_encoder2_resolution();
  ::PROTOBUF_NAMESPACE_ID::int32 encoder2_resolution() const;
  void set_encoder2_resolution(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_encoder2_resolution() const;
  void _internal_set_encoder2_resolution(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 spring_stiffness = 3;
  void clear_spring_stiffness();
  ::PROTOBUF_NAMESPACE_ID::int32 spring_stiffness() const;
  void set_spring_stiffness(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_spring_stiffness() const;
  void _internal_set_spring_stiffness(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sea.ConfigFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder1_resolution_;
  ::PROTOBUF_NAMESPACE_ID::int32 encoder2_resolution_;
  ::PROTOBUF_NAMESPACE_ID::int32 spring_stiffness_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class ControlFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.ControlFeedback) */ {
 public:
  inline ControlFeedback() : ControlFeedback(nullptr) {}
  ~ControlFeedback() override;
  explicit constexpr ControlFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlFeedback(const ControlFeedback& from);
  ControlFeedback(ControlFeedback&& from) noexcept
    : ControlFeedback() {
    *this = ::std::move(from);
  }

  inline ControlFeedback& operator=(const ControlFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlFeedback& operator=(ControlFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlFeedback& default_instance() {
    return *internal_default_instance();
  }
  enum FeedbackCase {
    kStatus = 1,
    kConfig = 2,
    FEEDBACK_NOT_SET = 0,
  };

  static inline const ControlFeedback* internal_default_instance() {
    return reinterpret_cast<const ControlFeedback*>(
               &_ControlFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ControlFeedback& a, ControlFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlFeedback* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlFeedback* New() const final {
    return new ControlFeedback();
  }

  ControlFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlFeedback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.ControlFeedback";
  }
  protected:
  explicit ControlFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // .sea.StatusFeedback status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::sea::StatusFeedback& status() const;
  PROTOBUF_MUST_USE_RESULT ::sea::StatusFeedback* release_status();
  ::sea::StatusFeedback* mutable_status();
  void set_allocated_status(::sea::StatusFeedback* status);
  private:
  const ::sea::StatusFeedback& _internal_status() const;
  ::sea::StatusFeedback* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::sea::StatusFeedback* status);
  ::sea::StatusFeedback* unsafe_arena_release_status();

  // .sea.ConfigFeedback config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sea::ConfigFeedback& config() const;
  PROTOBUF_MUST_USE_RESULT ::sea::ConfigFeedback* release_config();
  ::sea::ConfigFeedback* mutable_config();
  void set_allocated_config(::sea::ConfigFeedback* config);
  private:
  const ::sea::ConfigFeedback& _internal_config() const;
  ::sea::ConfigFeedback* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sea::ConfigFeedback* config);
  ::sea::ConfigFeedback* unsafe_arena_release_config();

  void clear_feedback();
  FeedbackCase feedback_case() const;
  // @@protoc_insertion_point(class_scope:sea.ControlFeedback)
 private:
  class _Internal;
  void set_has_status();
  void set_has_config();

  inline bool has_feedback() const;
  inline void clear_has_feedback();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FeedbackUnion {
    constexpr FeedbackUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sea::StatusFeedback* status_;
    ::sea::ConfigFeedback* config_;
  } feedback_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class SetStiffnessCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.SetStiffnessCommand) */ {
 public:
  inline SetStiffnessCommand() : SetStiffnessCommand(nullptr) {}
  ~SetStiffnessCommand() override;
  explicit constexpr SetStiffnessCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetStiffnessCommand(const SetStiffnessCommand& from);
  SetStiffnessCommand(SetStiffnessCommand&& from) noexcept
    : SetStiffnessCommand() {
    *this = ::std::move(from);
  }

  inline SetStiffnessCommand& operator=(const SetStiffnessCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetStiffnessCommand& operator=(SetStiffnessCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetStiffnessCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetStiffnessCommand* internal_default_instance() {
    return reinterpret_cast<const SetStiffnessCommand*>(
               &_SetStiffnessCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetStiffnessCommand& a, SetStiffnessCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SetStiffnessCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetStiffnessCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetStiffnessCommand* New() const final {
    return new SetStiffnessCommand();
  }

  SetStiffnessCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetStiffnessCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetStiffnessCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetStiffnessCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetStiffnessCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.SetStiffnessCommand";
  }
  protected:
  explicit SetStiffnessCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStiffnessFieldNumber = 1,
  };
  // double stiffness = 1;
  void clear_stiffness();
  double stiffness() const;
  void set_stiffness(double value);
  private:
  double _internal_stiffness() const;
  void _internal_set_stiffness(double value);
  public:

  // @@protoc_insertion_point(class_scope:sea.SetStiffnessCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double stiffness_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class SetDampingCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.SetDampingCommand) */ {
 public:
  inline SetDampingCommand() : SetDampingCommand(nullptr) {}
  ~SetDampingCommand() override;
  explicit constexpr SetDampingCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDampingCommand(const SetDampingCommand& from);
  SetDampingCommand(SetDampingCommand&& from) noexcept
    : SetDampingCommand() {
    *this = ::std::move(from);
  }

  inline SetDampingCommand& operator=(const SetDampingCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDampingCommand& operator=(SetDampingCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDampingCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDampingCommand* internal_default_instance() {
    return reinterpret_cast<const SetDampingCommand*>(
               &_SetDampingCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetDampingCommand& a, SetDampingCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDampingCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDampingCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetDampingCommand* New() const final {
    return new SetDampingCommand();
  }

  SetDampingCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetDampingCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDampingCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetDampingCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDampingCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.SetDampingCommand";
  }
  protected:
  explicit SetDampingCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDampingFieldNumber = 1,
  };
  // double damping = 1;
  void clear_damping();
  double damping() const;
  void set_damping(double value);
  private:
  double _internal_damping() const;
  void _internal_set_damping(double value);
  public:

  // @@protoc_insertion_point(class_scope:sea.SetDampingCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double damping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class SetWorkModeCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.SetWorkModeCommand) */ {
 public:
  inline SetWorkModeCommand() : SetWorkModeCommand(nullptr) {}
  ~SetWorkModeCommand() override;
  explicit constexpr SetWorkModeCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetWorkModeCommand(const SetWorkModeCommand& from);
  SetWorkModeCommand(SetWorkModeCommand&& from) noexcept
    : SetWorkModeCommand() {
    *this = ::std::move(from);
  }

  inline SetWorkModeCommand& operator=(const SetWorkModeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetWorkModeCommand& operator=(SetWorkModeCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetWorkModeCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetWorkModeCommand* internal_default_instance() {
    return reinterpret_cast<const SetWorkModeCommand*>(
               &_SetWorkModeCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetWorkModeCommand& a, SetWorkModeCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SetWorkModeCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetWorkModeCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetWorkModeCommand* New() const final {
    return new SetWorkModeCommand();
  }

  SetWorkModeCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetWorkModeCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetWorkModeCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetWorkModeCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetWorkModeCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.SetWorkModeCommand";
  }
  protected:
  explicit SetWorkModeCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkModeFieldNumber = 1,
  };
  // .sea.WorkMode work_mode = 1;
  void clear_work_mode();
  ::sea::WorkMode work_mode() const;
  void set_work_mode(::sea::WorkMode value);
  private:
  ::sea::WorkMode _internal_work_mode() const;
  void _internal_set_work_mode(::sea::WorkMode value);
  public:

  // @@protoc_insertion_point(class_scope:sea.SetWorkModeCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int work_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class EnableCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.EnableCommand) */ {
 public:
  inline EnableCommand() : EnableCommand(nullptr) {}
  ~EnableCommand() override;
  explicit constexpr EnableCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableCommand(const EnableCommand& from);
  EnableCommand(EnableCommand&& from) noexcept
    : EnableCommand() {
    *this = ::std::move(from);
  }

  inline EnableCommand& operator=(const EnableCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableCommand& operator=(EnableCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableCommand* internal_default_instance() {
    return reinterpret_cast<const EnableCommand*>(
               &_EnableCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EnableCommand& a, EnableCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnableCommand* New() const final {
    return new EnableCommand();
  }

  EnableCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnableCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.EnableCommand";
  }
  protected:
  explicit EnableCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sea.EnableCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class SetPositionCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.SetPositionCommand) */ {
 public:
  inline SetPositionCommand() : SetPositionCommand(nullptr) {}
  ~SetPositionCommand() override;
  explicit constexpr SetPositionCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPositionCommand(const SetPositionCommand& from);
  SetPositionCommand(SetPositionCommand&& from) noexcept
    : SetPositionCommand() {
    *this = ::std::move(from);
  }

  inline SetPositionCommand& operator=(const SetPositionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPositionCommand& operator=(SetPositionCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPositionCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPositionCommand* internal_default_instance() {
    return reinterpret_cast<const SetPositionCommand*>(
               &_SetPositionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SetPositionCommand& a, SetPositionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPositionCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPositionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetPositionCommand* New() const final {
    return new SetPositionCommand();
  }

  SetPositionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetPositionCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPositionCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetPositionCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPositionCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.SetPositionCommand";
  }
  protected:
  explicit SetPositionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // double position = 1;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // @@protoc_insertion_point(class_scope:sea.SetPositionCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class SetVelocityCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.SetVelocityCommand) */ {
 public:
  inline SetVelocityCommand() : SetVelocityCommand(nullptr) {}
  ~SetVelocityCommand() override;
  explicit constexpr SetVelocityCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVelocityCommand(const SetVelocityCommand& from);
  SetVelocityCommand(SetVelocityCommand&& from) noexcept
    : SetVelocityCommand() {
    *this = ::std::move(from);
  }

  inline SetVelocityCommand& operator=(const SetVelocityCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVelocityCommand& operator=(SetVelocityCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVelocityCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVelocityCommand* internal_default_instance() {
    return reinterpret_cast<const SetVelocityCommand*>(
               &_SetVelocityCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetVelocityCommand& a, SetVelocityCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVelocityCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVelocityCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetVelocityCommand* New() const final {
    return new SetVelocityCommand();
  }

  SetVelocityCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetVelocityCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVelocityCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetVelocityCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVelocityCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.SetVelocityCommand";
  }
  protected:
  explicit SetVelocityCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelocityFieldNumber = 1,
  };
  // double velocity = 1;
  void clear_velocity();
  double velocity() const;
  void set_velocity(double value);
  private:
  double _internal_velocity() const;
  void _internal_set_velocity(double value);
  public:

  // @@protoc_insertion_point(class_scope:sea.SetVelocityCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double velocity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sea_2eproto;
};
// -------------------------------------------------------------------

class ControlCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sea.ControlCommand) */ {
 public:
  inline ControlCommand() : ControlCommand(nullptr) {}
  ~ControlCommand() override;
  explicit constexpr ControlCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlCommand(const ControlCommand& from);
  ControlCommand(ControlCommand&& from) noexcept
    : ControlCommand() {
    *this = ::std::move(from);
  }

  inline ControlCommand& operator=(const ControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlCommand& operator=(ControlCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kSetStiffness = 1,
    kSetDamping = 2,
    kSetWorkMode = 3,
    kEnable = 4,
    kSetPosition = 5,
    kSetVelocity = 6,
    COMMAND_NOT_SET = 0,
  };

  static inline const ControlCommand* internal_default_instance() {
    return reinterpret_cast<const ControlCommand*>(
               &_ControlCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ControlCommand& a, ControlCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlCommand* New() const final {
    return new ControlCommand();
  }

  ControlCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sea.ControlCommand";
  }
  protected:
  explicit ControlCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetStiffnessFieldNumber = 1,
    kSetDampingFieldNumber = 2,
    kSetWorkModeFieldNumber = 3,
    kEnableFieldNumber = 4,
    kSetPositionFieldNumber = 5,
    kSetVelocityFieldNumber = 6,
  };
  // .sea.SetStiffnessCommand set_stiffness = 1;
  bool has_set_stiffness() const;
  private:
  bool _internal_has_set_stiffness() const;
  public:
  void clear_set_stiffness();
  const ::sea::SetStiffnessCommand& set_stiffness() const;
  PROTOBUF_MUST_USE_RESULT ::sea::SetStiffnessCommand* release_set_stiffness();
  ::sea::SetStiffnessCommand* mutable_set_stiffness();
  void set_allocated_set_stiffness(::sea::SetStiffnessCommand* set_stiffness);
  private:
  const ::sea::SetStiffnessCommand& _internal_set_stiffness() const;
  ::sea::SetStiffnessCommand* _internal_mutable_set_stiffness();
  public:
  void unsafe_arena_set_allocated_set_stiffness(
      ::sea::SetStiffnessCommand* set_stiffness);
  ::sea::SetStiffnessCommand* unsafe_arena_release_set_stiffness();

  // .sea.SetDampingCommand set_damping = 2;
  bool has_set_damping() const;
  private:
  bool _internal_has_set_damping() const;
  public:
  void clear_set_damping();
  const ::sea::SetDampingCommand& set_damping() const;
  PROTOBUF_MUST_USE_RESULT ::sea::SetDampingCommand* release_set_damping();
  ::sea::SetDampingCommand* mutable_set_damping();
  void set_allocated_set_damping(::sea::SetDampingCommand* set_damping);
  private:
  const ::sea::SetDampingCommand& _internal_set_damping() const;
  ::sea::SetDampingCommand* _internal_mutable_set_damping();
  public:
  void unsafe_arena_set_allocated_set_damping(
      ::sea::SetDampingCommand* set_damping);
  ::sea::SetDampingCommand* unsafe_arena_release_set_damping();

  // .sea.SetWorkModeCommand set_work_mode = 3;
  bool has_set_work_mode() const;
  private:
  bool _internal_has_set_work_mode() const;
  public:
  void clear_set_work_mode();
  const ::sea::SetWorkModeCommand& set_work_mode() const;
  PROTOBUF_MUST_USE_RESULT ::sea::SetWorkModeCommand* release_set_work_mode();
  ::sea::SetWorkModeCommand* mutable_set_work_mode();
  void set_allocated_set_work_mode(::sea::SetWorkModeCommand* set_work_mode);
  private:
  const ::sea::SetWorkModeCommand& _internal_set_work_mode() const;
  ::sea::SetWorkModeCommand* _internal_mutable_set_work_mode();
  public:
  void unsafe_arena_set_allocated_set_work_mode(
      ::sea::SetWorkModeCommand* set_work_mode);
  ::sea::SetWorkModeCommand* unsafe_arena_release_set_work_mode();

  // .sea.EnableCommand enable = 4;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  const ::sea::EnableCommand& enable() const;
  PROTOBUF_MUST_USE_RESULT ::sea::EnableCommand* release_enable();
  ::sea::EnableCommand* mutable_enable();
  void set_allocated_enable(::sea::EnableCommand* enable);
  private:
  const ::sea::EnableCommand& _internal_enable() const;
  ::sea::EnableCommand* _internal_mutable_enable();
  public:
  void unsafe_arena_set_allocated_enable(
      ::sea::EnableCommand* enable);
  ::sea::EnableCommand* unsafe_arena_release_enable();

  // .sea.SetPositionCommand set_position = 5;
  bool has_set_position() const;
  private:
  bool _internal_has_set_position() const;
  public:
  void clear_set_position();
  const ::sea::SetPositionCommand& set_position() const;
  PROTOBUF_MUST_USE_RESULT ::sea::SetPositionCommand* release_set_position();
  ::sea::SetPositionCommand* mutable_set_position();
  void set_allocated_set_position(::sea::SetPositionCommand* set_position);
  private:
  const ::sea::SetPositionCommand& _internal_set_position() const;
  ::sea::SetPositionCommand* _internal_mutable_set_position();
  public:
  void unsafe_arena_set_allocated_set_position(
      ::sea::SetPositionCommand* set_position);
  ::sea::SetPositionCommand* unsafe_arena_release_set_position();

  // .sea.SetVelocityCommand set_velocity = 6;
  bool has_set_velocity() const;
  private:
  bool _internal_has_set_velocity() const;
  public:
  void clear_set_velocity();
  const ::sea::SetVelocityCommand& set_velocity() const;
  PROTOBUF_MUST_USE_RESULT ::sea::SetVelocityCommand* release_set_velocity();
  ::sea::SetVelocityCommand* mutable_set_velocity();
  void set_allocated_set_velocity(::sea::SetVelocityCommand* set_velocity);
  private:
  const ::sea::SetVelocityCommand& _internal_set_velocity() const;
  ::sea::SetVelocityCommand* _internal_mutable_set_velocity();
  public:
  void unsafe_arena_set_allocated_set_velocity(
      ::sea::SetVelocityCommand* set_velocity);
  ::sea::SetVelocityCommand* unsafe_arena_release_set_velocity();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:sea.ControlCommand)
 private:
  class _Internal;
  void set_has_set_stiffness();
  void set_has_set_damping();
  void set_has_set_work_mode();
  void set_has_enable();
  void set_has_set_position();
  void set_has_set_velocity();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sea::SetStiffnessCommand* set_stiffness_;
    ::sea::SetDampingCommand* set_damping_;
    ::sea::SetWorkModeCommand* set_work_mode_;
    ::sea::EnableCommand* enable_;
    ::sea::SetPositionCommand* set_position_;
    ::sea::SetVelocityCommand* set_velocity_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_sea_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StatusFeedback

// .sea.RunState run_state = 1;
inline void StatusFeedback::clear_run_state() {
  run_state_ = 0;
}
inline ::sea::RunState StatusFeedback::_internal_run_state() const {
  return static_cast< ::sea::RunState >(run_state_);
}
inline ::sea::RunState StatusFeedback::run_state() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.run_state)
  return _internal_run_state();
}
inline void StatusFeedback::_internal_set_run_state(::sea::RunState value) {
  
  run_state_ = value;
}
inline void StatusFeedback::set_run_state(::sea::RunState value) {
  _internal_set_run_state(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.run_state)
}

// .sea.WorkMode work_mode = 2;
inline void StatusFeedback::clear_work_mode() {
  work_mode_ = 0;
}
inline ::sea::WorkMode StatusFeedback::_internal_work_mode() const {
  return static_cast< ::sea::WorkMode >(work_mode_);
}
inline ::sea::WorkMode StatusFeedback::work_mode() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.work_mode)
  return _internal_work_mode();
}
inline void StatusFeedback::_internal_set_work_mode(::sea::WorkMode value) {
  
  work_mode_ = value;
}
inline void StatusFeedback::set_work_mode(::sea::WorkMode value) {
  _internal_set_work_mode(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.work_mode)
}

// double current_position = 3;
inline void StatusFeedback::clear_current_position() {
  current_position_ = 0;
}
inline double StatusFeedback::_internal_current_position() const {
  return current_position_;
}
inline double StatusFeedback::current_position() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.current_position)
  return _internal_current_position();
}
inline void StatusFeedback::_internal_set_current_position(double value) {
  
  current_position_ = value;
}
inline void StatusFeedback::set_current_position(double value) {
  _internal_set_current_position(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.current_position)
}

// double current_velocity = 4;
inline void StatusFeedback::clear_current_velocity() {
  current_velocity_ = 0;
}
inline double StatusFeedback::_internal_current_velocity() const {
  return current_velocity_;
}
inline double StatusFeedback::current_velocity() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.current_velocity)
  return _internal_current_velocity();
}
inline void StatusFeedback::_internal_set_current_velocity(double value) {
  
  current_velocity_ = value;
}
inline void StatusFeedback::set_current_velocity(double value) {
  _internal_set_current_velocity(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.current_velocity)
}

// int32 encoder1_feedback = 5;
inline void StatusFeedback::clear_encoder1_feedback() {
  encoder1_feedback_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusFeedback::_internal_encoder1_feedback() const {
  return encoder1_feedback_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusFeedback::encoder1_feedback() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.encoder1_feedback)
  return _internal_encoder1_feedback();
}
inline void StatusFeedback::_internal_set_encoder1_feedback(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  encoder1_feedback_ = value;
}
inline void StatusFeedback::set_encoder1_feedback(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder1_feedback(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.encoder1_feedback)
}

// int32 encoder2_feedback = 6;
inline void StatusFeedback::clear_encoder2_feedback() {
  encoder2_feedback_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusFeedback::_internal_encoder2_feedback() const {
  return encoder2_feedback_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusFeedback::encoder2_feedback() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.encoder2_feedback)
  return _internal_encoder2_feedback();
}
inline void StatusFeedback::_internal_set_encoder2_feedback(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  encoder2_feedback_ = value;
}
inline void StatusFeedback::set_encoder2_feedback(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder2_feedback(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.encoder2_feedback)
}

// double external_force = 7;
inline void StatusFeedback::clear_external_force() {
  external_force_ = 0;
}
inline double StatusFeedback::_internal_external_force() const {
  return external_force_;
}
inline double StatusFeedback::external_force() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.external_force)
  return _internal_external_force();
}
inline void StatusFeedback::_internal_set_external_force(double value) {
  
  external_force_ = value;
}
inline void StatusFeedback::set_external_force(double value) {
  _internal_set_external_force(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.external_force)
}

// double stiffness = 8;
inline void StatusFeedback::clear_stiffness() {
  stiffness_ = 0;
}
inline double StatusFeedback::_internal_stiffness() const {
  return stiffness_;
}
inline double StatusFeedback::stiffness() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.stiffness)
  return _internal_stiffness();
}
inline void StatusFeedback::_internal_set_stiffness(double value) {
  
  stiffness_ = value;
}
inline void StatusFeedback::set_stiffness(double value) {
  _internal_set_stiffness(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.stiffness)
}

// double damping = 9;
inline void StatusFeedback::clear_damping() {
  damping_ = 0;
}
inline double StatusFeedback::_internal_damping() const {
  return damping_;
}
inline double StatusFeedback::damping() const {
  // @@protoc_insertion_point(field_get:sea.StatusFeedback.damping)
  return _internal_damping();
}
inline void StatusFeedback::_internal_set_damping(double value) {
  
  damping_ = value;
}
inline void StatusFeedback::set_damping(double value) {
  _internal_set_damping(value);
  // @@protoc_insertion_point(field_set:sea.StatusFeedback.damping)
}

// -------------------------------------------------------------------

// ConfigFeedback

// int32 encoder1_resolution = 1;
inline void ConfigFeedback::clear_encoder1_resolution() {
  encoder1_resolution_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::_internal_encoder1_resolution() const {
  return encoder1_resolution_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::encoder1_resolution() const {
  // @@protoc_insertion_point(field_get:sea.ConfigFeedback.encoder1_resolution)
  return _internal_encoder1_resolution();
}
inline void ConfigFeedback::_internal_set_encoder1_resolution(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  encoder1_resolution_ = value;
}
inline void ConfigFeedback::set_encoder1_resolution(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder1_resolution(value);
  // @@protoc_insertion_point(field_set:sea.ConfigFeedback.encoder1_resolution)
}

// int32 encoder2_resolution = 2;
inline void ConfigFeedback::clear_encoder2_resolution() {
  encoder2_resolution_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::_internal_encoder2_resolution() const {
  return encoder2_resolution_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::encoder2_resolution() const {
  // @@protoc_insertion_point(field_get:sea.ConfigFeedback.encoder2_resolution)
  return _internal_encoder2_resolution();
}
inline void ConfigFeedback::_internal_set_encoder2_resolution(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  encoder2_resolution_ = value;
}
inline void ConfigFeedback::set_encoder2_resolution(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_encoder2_resolution(value);
  // @@protoc_insertion_point(field_set:sea.ConfigFeedback.encoder2_resolution)
}

// int32 spring_stiffness = 3;
inline void ConfigFeedback::clear_spring_stiffness() {
  spring_stiffness_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::_internal_spring_stiffness() const {
  return spring_stiffness_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigFeedback::spring_stiffness() const {
  // @@protoc_insertion_point(field_get:sea.ConfigFeedback.spring_stiffness)
  return _internal_spring_stiffness();
}
inline void ConfigFeedback::_internal_set_spring_stiffness(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  spring_stiffness_ = value;
}
inline void ConfigFeedback::set_spring_stiffness(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_spring_stiffness(value);
  // @@protoc_insertion_point(field_set:sea.ConfigFeedback.spring_stiffness)
}

// -------------------------------------------------------------------

// ControlFeedback

// .sea.StatusFeedback status = 1;
inline bool ControlFeedback::_internal_has_status() const {
  return feedback_case() == kStatus;
}
inline bool ControlFeedback::has_status() const {
  return _internal_has_status();
}
inline void ControlFeedback::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void ControlFeedback::clear_status() {
  if (_internal_has_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete feedback_.status_;
    }
    clear_has_feedback();
  }
}
inline ::sea::StatusFeedback* ControlFeedback::release_status() {
  // @@protoc_insertion_point(field_release:sea.ControlFeedback.status)
  if (_internal_has_status()) {
    clear_has_feedback();
      ::sea::StatusFeedback* temp = feedback_.status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    feedback_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::StatusFeedback& ControlFeedback::_internal_status() const {
  return _internal_has_status()
      ? *feedback_.status_
      : reinterpret_cast< ::sea::StatusFeedback&>(::sea::_StatusFeedback_default_instance_);
}
inline const ::sea::StatusFeedback& ControlFeedback::status() const {
  // @@protoc_insertion_point(field_get:sea.ControlFeedback.status)
  return _internal_status();
}
inline ::sea::StatusFeedback* ControlFeedback::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlFeedback.status)
  if (_internal_has_status()) {
    clear_has_feedback();
    ::sea::StatusFeedback* temp = feedback_.status_;
    feedback_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlFeedback::unsafe_arena_set_allocated_status(::sea::StatusFeedback* status) {
  clear_feedback();
  if (status) {
    set_has_status();
    feedback_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlFeedback.status)
}
inline ::sea::StatusFeedback* ControlFeedback::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_feedback();
    set_has_status();
    feedback_.status_ = CreateMaybeMessage< ::sea::StatusFeedback >(GetArenaForAllocation());
  }
  return feedback_.status_;
}
inline ::sea::StatusFeedback* ControlFeedback::mutable_status() {
  ::sea::StatusFeedback* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:sea.ControlFeedback.status)
  return _msg;
}

// .sea.ConfigFeedback config = 2;
inline bool ControlFeedback::_internal_has_config() const {
  return feedback_case() == kConfig;
}
inline bool ControlFeedback::has_config() const {
  return _internal_has_config();
}
inline void ControlFeedback::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void ControlFeedback::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete feedback_.config_;
    }
    clear_has_feedback();
  }
}
inline ::sea::ConfigFeedback* ControlFeedback::release_config() {
  // @@protoc_insertion_point(field_release:sea.ControlFeedback.config)
  if (_internal_has_config()) {
    clear_has_feedback();
      ::sea::ConfigFeedback* temp = feedback_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    feedback_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::ConfigFeedback& ControlFeedback::_internal_config() const {
  return _internal_has_config()
      ? *feedback_.config_
      : reinterpret_cast< ::sea::ConfigFeedback&>(::sea::_ConfigFeedback_default_instance_);
}
inline const ::sea::ConfigFeedback& ControlFeedback::config() const {
  // @@protoc_insertion_point(field_get:sea.ControlFeedback.config)
  return _internal_config();
}
inline ::sea::ConfigFeedback* ControlFeedback::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlFeedback.config)
  if (_internal_has_config()) {
    clear_has_feedback();
    ::sea::ConfigFeedback* temp = feedback_.config_;
    feedback_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlFeedback::unsafe_arena_set_allocated_config(::sea::ConfigFeedback* config) {
  clear_feedback();
  if (config) {
    set_has_config();
    feedback_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlFeedback.config)
}
inline ::sea::ConfigFeedback* ControlFeedback::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_feedback();
    set_has_config();
    feedback_.config_ = CreateMaybeMessage< ::sea::ConfigFeedback >(GetArenaForAllocation());
  }
  return feedback_.config_;
}
inline ::sea::ConfigFeedback* ControlFeedback::mutable_config() {
  ::sea::ConfigFeedback* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sea.ControlFeedback.config)
  return _msg;
}

inline bool ControlFeedback::has_feedback() const {
  return feedback_case() != FEEDBACK_NOT_SET;
}
inline void ControlFeedback::clear_has_feedback() {
  _oneof_case_[0] = FEEDBACK_NOT_SET;
}
inline ControlFeedback::FeedbackCase ControlFeedback::feedback_case() const {
  return ControlFeedback::FeedbackCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetStiffnessCommand

// double stiffness = 1;
inline void SetStiffnessCommand::clear_stiffness() {
  stiffness_ = 0;
}
inline double SetStiffnessCommand::_internal_stiffness() const {
  return stiffness_;
}
inline double SetStiffnessCommand::stiffness() const {
  // @@protoc_insertion_point(field_get:sea.SetStiffnessCommand.stiffness)
  return _internal_stiffness();
}
inline void SetStiffnessCommand::_internal_set_stiffness(double value) {
  
  stiffness_ = value;
}
inline void SetStiffnessCommand::set_stiffness(double value) {
  _internal_set_stiffness(value);
  // @@protoc_insertion_point(field_set:sea.SetStiffnessCommand.stiffness)
}

// -------------------------------------------------------------------

// SetDampingCommand

// double damping = 1;
inline void SetDampingCommand::clear_damping() {
  damping_ = 0;
}
inline double SetDampingCommand::_internal_damping() const {
  return damping_;
}
inline double SetDampingCommand::damping() const {
  // @@protoc_insertion_point(field_get:sea.SetDampingCommand.damping)
  return _internal_damping();
}
inline void SetDampingCommand::_internal_set_damping(double value) {
  
  damping_ = value;
}
inline void SetDampingCommand::set_damping(double value) {
  _internal_set_damping(value);
  // @@protoc_insertion_point(field_set:sea.SetDampingCommand.damping)
}

// -------------------------------------------------------------------

// SetWorkModeCommand

// .sea.WorkMode work_mode = 1;
inline void SetWorkModeCommand::clear_work_mode() {
  work_mode_ = 0;
}
inline ::sea::WorkMode SetWorkModeCommand::_internal_work_mode() const {
  return static_cast< ::sea::WorkMode >(work_mode_);
}
inline ::sea::WorkMode SetWorkModeCommand::work_mode() const {
  // @@protoc_insertion_point(field_get:sea.SetWorkModeCommand.work_mode)
  return _internal_work_mode();
}
inline void SetWorkModeCommand::_internal_set_work_mode(::sea::WorkMode value) {
  
  work_mode_ = value;
}
inline void SetWorkModeCommand::set_work_mode(::sea::WorkMode value) {
  _internal_set_work_mode(value);
  // @@protoc_insertion_point(field_set:sea.SetWorkModeCommand.work_mode)
}

// -------------------------------------------------------------------

// EnableCommand

// bool enable = 1;
inline void EnableCommand::clear_enable() {
  enable_ = false;
}
inline bool EnableCommand::_internal_enable() const {
  return enable_;
}
inline bool EnableCommand::enable() const {
  // @@protoc_insertion_point(field_get:sea.EnableCommand.enable)
  return _internal_enable();
}
inline void EnableCommand::_internal_set_enable(bool value) {
  
  enable_ = value;
}
inline void EnableCommand::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:sea.EnableCommand.enable)
}

// -------------------------------------------------------------------

// SetPositionCommand

// double position = 1;
inline void SetPositionCommand::clear_position() {
  position_ = 0;
}
inline double SetPositionCommand::_internal_position() const {
  return position_;
}
inline double SetPositionCommand::position() const {
  // @@protoc_insertion_point(field_get:sea.SetPositionCommand.position)
  return _internal_position();
}
inline void SetPositionCommand::_internal_set_position(double value) {
  
  position_ = value;
}
inline void SetPositionCommand::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:sea.SetPositionCommand.position)
}

// -------------------------------------------------------------------

// SetVelocityCommand

// double velocity = 1;
inline void SetVelocityCommand::clear_velocity() {
  velocity_ = 0;
}
inline double SetVelocityCommand::_internal_velocity() const {
  return velocity_;
}
inline double SetVelocityCommand::velocity() const {
  // @@protoc_insertion_point(field_get:sea.SetVelocityCommand.velocity)
  return _internal_velocity();
}
inline void SetVelocityCommand::_internal_set_velocity(double value) {
  
  velocity_ = value;
}
inline void SetVelocityCommand::set_velocity(double value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:sea.SetVelocityCommand.velocity)
}

// -------------------------------------------------------------------

// ControlCommand

// .sea.SetStiffnessCommand set_stiffness = 1;
inline bool ControlCommand::_internal_has_set_stiffness() const {
  return command_case() == kSetStiffness;
}
inline bool ControlCommand::has_set_stiffness() const {
  return _internal_has_set_stiffness();
}
inline void ControlCommand::set_has_set_stiffness() {
  _oneof_case_[0] = kSetStiffness;
}
inline void ControlCommand::clear_set_stiffness() {
  if (_internal_has_set_stiffness()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.set_stiffness_;
    }
    clear_has_command();
  }
}
inline ::sea::SetStiffnessCommand* ControlCommand::release_set_stiffness() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.set_stiffness)
  if (_internal_has_set_stiffness()) {
    clear_has_command();
      ::sea::SetStiffnessCommand* temp = command_.set_stiffness_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.set_stiffness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::SetStiffnessCommand& ControlCommand::_internal_set_stiffness() const {
  return _internal_has_set_stiffness()
      ? *command_.set_stiffness_
      : reinterpret_cast< ::sea::SetStiffnessCommand&>(::sea::_SetStiffnessCommand_default_instance_);
}
inline const ::sea::SetStiffnessCommand& ControlCommand::set_stiffness() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.set_stiffness)
  return _internal_set_stiffness();
}
inline ::sea::SetStiffnessCommand* ControlCommand::unsafe_arena_release_set_stiffness() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.set_stiffness)
  if (_internal_has_set_stiffness()) {
    clear_has_command();
    ::sea::SetStiffnessCommand* temp = command_.set_stiffness_;
    command_.set_stiffness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_set_stiffness(::sea::SetStiffnessCommand* set_stiffness) {
  clear_command();
  if (set_stiffness) {
    set_has_set_stiffness();
    command_.set_stiffness_ = set_stiffness;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.set_stiffness)
}
inline ::sea::SetStiffnessCommand* ControlCommand::_internal_mutable_set_stiffness() {
  if (!_internal_has_set_stiffness()) {
    clear_command();
    set_has_set_stiffness();
    command_.set_stiffness_ = CreateMaybeMessage< ::sea::SetStiffnessCommand >(GetArenaForAllocation());
  }
  return command_.set_stiffness_;
}
inline ::sea::SetStiffnessCommand* ControlCommand::mutable_set_stiffness() {
  ::sea::SetStiffnessCommand* _msg = _internal_mutable_set_stiffness();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.set_stiffness)
  return _msg;
}

// .sea.SetDampingCommand set_damping = 2;
inline bool ControlCommand::_internal_has_set_damping() const {
  return command_case() == kSetDamping;
}
inline bool ControlCommand::has_set_damping() const {
  return _internal_has_set_damping();
}
inline void ControlCommand::set_has_set_damping() {
  _oneof_case_[0] = kSetDamping;
}
inline void ControlCommand::clear_set_damping() {
  if (_internal_has_set_damping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.set_damping_;
    }
    clear_has_command();
  }
}
inline ::sea::SetDampingCommand* ControlCommand::release_set_damping() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.set_damping)
  if (_internal_has_set_damping()) {
    clear_has_command();
      ::sea::SetDampingCommand* temp = command_.set_damping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.set_damping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::SetDampingCommand& ControlCommand::_internal_set_damping() const {
  return _internal_has_set_damping()
      ? *command_.set_damping_
      : reinterpret_cast< ::sea::SetDampingCommand&>(::sea::_SetDampingCommand_default_instance_);
}
inline const ::sea::SetDampingCommand& ControlCommand::set_damping() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.set_damping)
  return _internal_set_damping();
}
inline ::sea::SetDampingCommand* ControlCommand::unsafe_arena_release_set_damping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.set_damping)
  if (_internal_has_set_damping()) {
    clear_has_command();
    ::sea::SetDampingCommand* temp = command_.set_damping_;
    command_.set_damping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_set_damping(::sea::SetDampingCommand* set_damping) {
  clear_command();
  if (set_damping) {
    set_has_set_damping();
    command_.set_damping_ = set_damping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.set_damping)
}
inline ::sea::SetDampingCommand* ControlCommand::_internal_mutable_set_damping() {
  if (!_internal_has_set_damping()) {
    clear_command();
    set_has_set_damping();
    command_.set_damping_ = CreateMaybeMessage< ::sea::SetDampingCommand >(GetArenaForAllocation());
  }
  return command_.set_damping_;
}
inline ::sea::SetDampingCommand* ControlCommand::mutable_set_damping() {
  ::sea::SetDampingCommand* _msg = _internal_mutable_set_damping();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.set_damping)
  return _msg;
}

// .sea.SetWorkModeCommand set_work_mode = 3;
inline bool ControlCommand::_internal_has_set_work_mode() const {
  return command_case() == kSetWorkMode;
}
inline bool ControlCommand::has_set_work_mode() const {
  return _internal_has_set_work_mode();
}
inline void ControlCommand::set_has_set_work_mode() {
  _oneof_case_[0] = kSetWorkMode;
}
inline void ControlCommand::clear_set_work_mode() {
  if (_internal_has_set_work_mode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.set_work_mode_;
    }
    clear_has_command();
  }
}
inline ::sea::SetWorkModeCommand* ControlCommand::release_set_work_mode() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.set_work_mode)
  if (_internal_has_set_work_mode()) {
    clear_has_command();
      ::sea::SetWorkModeCommand* temp = command_.set_work_mode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.set_work_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::SetWorkModeCommand& ControlCommand::_internal_set_work_mode() const {
  return _internal_has_set_work_mode()
      ? *command_.set_work_mode_
      : reinterpret_cast< ::sea::SetWorkModeCommand&>(::sea::_SetWorkModeCommand_default_instance_);
}
inline const ::sea::SetWorkModeCommand& ControlCommand::set_work_mode() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.set_work_mode)
  return _internal_set_work_mode();
}
inline ::sea::SetWorkModeCommand* ControlCommand::unsafe_arena_release_set_work_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.set_work_mode)
  if (_internal_has_set_work_mode()) {
    clear_has_command();
    ::sea::SetWorkModeCommand* temp = command_.set_work_mode_;
    command_.set_work_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_set_work_mode(::sea::SetWorkModeCommand* set_work_mode) {
  clear_command();
  if (set_work_mode) {
    set_has_set_work_mode();
    command_.set_work_mode_ = set_work_mode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.set_work_mode)
}
inline ::sea::SetWorkModeCommand* ControlCommand::_internal_mutable_set_work_mode() {
  if (!_internal_has_set_work_mode()) {
    clear_command();
    set_has_set_work_mode();
    command_.set_work_mode_ = CreateMaybeMessage< ::sea::SetWorkModeCommand >(GetArenaForAllocation());
  }
  return command_.set_work_mode_;
}
inline ::sea::SetWorkModeCommand* ControlCommand::mutable_set_work_mode() {
  ::sea::SetWorkModeCommand* _msg = _internal_mutable_set_work_mode();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.set_work_mode)
  return _msg;
}

// .sea.EnableCommand enable = 4;
inline bool ControlCommand::_internal_has_enable() const {
  return command_case() == kEnable;
}
inline bool ControlCommand::has_enable() const {
  return _internal_has_enable();
}
inline void ControlCommand::set_has_enable() {
  _oneof_case_[0] = kEnable;
}
inline void ControlCommand::clear_enable() {
  if (_internal_has_enable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.enable_;
    }
    clear_has_command();
  }
}
inline ::sea::EnableCommand* ControlCommand::release_enable() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.enable)
  if (_internal_has_enable()) {
    clear_has_command();
      ::sea::EnableCommand* temp = command_.enable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.enable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::EnableCommand& ControlCommand::_internal_enable() const {
  return _internal_has_enable()
      ? *command_.enable_
      : reinterpret_cast< ::sea::EnableCommand&>(::sea::_EnableCommand_default_instance_);
}
inline const ::sea::EnableCommand& ControlCommand::enable() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.enable)
  return _internal_enable();
}
inline ::sea::EnableCommand* ControlCommand::unsafe_arena_release_enable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.enable)
  if (_internal_has_enable()) {
    clear_has_command();
    ::sea::EnableCommand* temp = command_.enable_;
    command_.enable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_enable(::sea::EnableCommand* enable) {
  clear_command();
  if (enable) {
    set_has_enable();
    command_.enable_ = enable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.enable)
}
inline ::sea::EnableCommand* ControlCommand::_internal_mutable_enable() {
  if (!_internal_has_enable()) {
    clear_command();
    set_has_enable();
    command_.enable_ = CreateMaybeMessage< ::sea::EnableCommand >(GetArenaForAllocation());
  }
  return command_.enable_;
}
inline ::sea::EnableCommand* ControlCommand::mutable_enable() {
  ::sea::EnableCommand* _msg = _internal_mutable_enable();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.enable)
  return _msg;
}

// .sea.SetPositionCommand set_position = 5;
inline bool ControlCommand::_internal_has_set_position() const {
  return command_case() == kSetPosition;
}
inline bool ControlCommand::has_set_position() const {
  return _internal_has_set_position();
}
inline void ControlCommand::set_has_set_position() {
  _oneof_case_[0] = kSetPosition;
}
inline void ControlCommand::clear_set_position() {
  if (_internal_has_set_position()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.set_position_;
    }
    clear_has_command();
  }
}
inline ::sea::SetPositionCommand* ControlCommand::release_set_position() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.set_position)
  if (_internal_has_set_position()) {
    clear_has_command();
      ::sea::SetPositionCommand* temp = command_.set_position_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.set_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::SetPositionCommand& ControlCommand::_internal_set_position() const {
  return _internal_has_set_position()
      ? *command_.set_position_
      : reinterpret_cast< ::sea::SetPositionCommand&>(::sea::_SetPositionCommand_default_instance_);
}
inline const ::sea::SetPositionCommand& ControlCommand::set_position() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.set_position)
  return _internal_set_position();
}
inline ::sea::SetPositionCommand* ControlCommand::unsafe_arena_release_set_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.set_position)
  if (_internal_has_set_position()) {
    clear_has_command();
    ::sea::SetPositionCommand* temp = command_.set_position_;
    command_.set_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_set_position(::sea::SetPositionCommand* set_position) {
  clear_command();
  if (set_position) {
    set_has_set_position();
    command_.set_position_ = set_position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.set_position)
}
inline ::sea::SetPositionCommand* ControlCommand::_internal_mutable_set_position() {
  if (!_internal_has_set_position()) {
    clear_command();
    set_has_set_position();
    command_.set_position_ = CreateMaybeMessage< ::sea::SetPositionCommand >(GetArenaForAllocation());
  }
  return command_.set_position_;
}
inline ::sea::SetPositionCommand* ControlCommand::mutable_set_position() {
  ::sea::SetPositionCommand* _msg = _internal_mutable_set_position();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.set_position)
  return _msg;
}

// .sea.SetVelocityCommand set_velocity = 6;
inline bool ControlCommand::_internal_has_set_velocity() const {
  return command_case() == kSetVelocity;
}
inline bool ControlCommand::has_set_velocity() const {
  return _internal_has_set_velocity();
}
inline void ControlCommand::set_has_set_velocity() {
  _oneof_case_[0] = kSetVelocity;
}
inline void ControlCommand::clear_set_velocity() {
  if (_internal_has_set_velocity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.set_velocity_;
    }
    clear_has_command();
  }
}
inline ::sea::SetVelocityCommand* ControlCommand::release_set_velocity() {
  // @@protoc_insertion_point(field_release:sea.ControlCommand.set_velocity)
  if (_internal_has_set_velocity()) {
    clear_has_command();
      ::sea::SetVelocityCommand* temp = command_.set_velocity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.set_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sea::SetVelocityCommand& ControlCommand::_internal_set_velocity() const {
  return _internal_has_set_velocity()
      ? *command_.set_velocity_
      : reinterpret_cast< ::sea::SetVelocityCommand&>(::sea::_SetVelocityCommand_default_instance_);
}
inline const ::sea::SetVelocityCommand& ControlCommand::set_velocity() const {
  // @@protoc_insertion_point(field_get:sea.ControlCommand.set_velocity)
  return _internal_set_velocity();
}
inline ::sea::SetVelocityCommand* ControlCommand::unsafe_arena_release_set_velocity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sea.ControlCommand.set_velocity)
  if (_internal_has_set_velocity()) {
    clear_has_command();
    ::sea::SetVelocityCommand* temp = command_.set_velocity_;
    command_.set_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlCommand::unsafe_arena_set_allocated_set_velocity(::sea::SetVelocityCommand* set_velocity) {
  clear_command();
  if (set_velocity) {
    set_has_set_velocity();
    command_.set_velocity_ = set_velocity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sea.ControlCommand.set_velocity)
}
inline ::sea::SetVelocityCommand* ControlCommand::_internal_mutable_set_velocity() {
  if (!_internal_has_set_velocity()) {
    clear_command();
    set_has_set_velocity();
    command_.set_velocity_ = CreateMaybeMessage< ::sea::SetVelocityCommand >(GetArenaForAllocation());
  }
  return command_.set_velocity_;
}
inline ::sea::SetVelocityCommand* ControlCommand::mutable_set_velocity() {
  ::sea::SetVelocityCommand* _msg = _internal_mutable_set_velocity();
  // @@protoc_insertion_point(field_mutable:sea.ControlCommand.set_velocity)
  return _msg;
}

inline bool ControlCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void ControlCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline ControlCommand::CommandCase ControlCommand::command_case() const {
  return ControlCommand::CommandCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sea

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sea::RunState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sea::RunState>() {
  return ::sea::RunState_descriptor();
}
template <> struct is_proto_enum< ::sea::WorkMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sea::WorkMode>() {
  return ::sea::WorkMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sea_2eproto
